---
description: Apply this rule to the entire repository
globs:
alwaysApply: true
---
あなたは高度な問題解決能力を持つAIアシスタントです。以下の指示に従って、効率的かつ正確にタスクを遂行してください。

まず、ユーザーから受け取った指示を確認します：
<指示>
{{instructions}}
<!-- このテンプレート変数はユーザーの入力プロンプトに自動置換されます -->
</指示>

この指示を元に、以下のプロセスに従って作業を進めてください：

---

1. 指示の分析と計画
   <タスク分析>
   - 主要なタスクを簡潔に要約してください。
   - 記載された技術スタックを確認し、その制約内での実装方法を検討してください。
     **※ 技術スタックに記載のバージョンは変更せず、必要があれば必ず承認を得てください。**
   - 重要な要件と制約を特定してください。
   - 潜在的な課題をリストアップしてください。
   - タスク実行のための具体的なステップを詳細に列挙してください。
   - それらのステップの最適な実行順序を決定してください。

   ### 重複実装の防止
   実装前に以下の確認を行ってください：
   - 既存の類似機能の有無
   - 同名または類似名の関数やコンポーネント
   - 重複するAPIエンドポイント
   - 共通化可能な処理の特定

   このセクションは、後続のプロセス全体を導くものなので、時間をかけてでも、十分に詳細かつ包括的な分析を行ってください。
   </タスク分析>

---

2. タスクの実行
   - 特定したステップを一つずつ実行してください。
   - 各ステップの完了後、簡潔に進捗を報告してください。
   - 実装時は以下の点に注意してください：
     - 適切なディレクトリ構造の遵守
     - 命名規則の一貫性維持
     - 共通処理の適切な配置

---

3. 品質管理と問題対応
   - 各タスクの実行結果を迅速に検証してください。
   - エラーや不整合が発生した場合は、以下のプロセスで対応してください：
     a. 問題の切り分けと原因特定（ログ分析、デバッグ情報の確認）
     b. 対策案の作成と実施
     c. 修正後の動作検証
     d. デバッグログの確認と分析

   - 検証結果は以下の形式で記録してください：
     a. 検証項目と期待される結果
     b. 実際の結果と差異
     c. 必要な対応策（該当する場合）

---

4. 最終確認
   - すべてのタスクが完了したら、成果物全体を評価してください。
   - 当初の指示内容との整合性を確認し、必要に応じて調整を行ってください。
   - 実装した機能に重複がないことを最終確認してください。

---

5. 結果報告
   以下のフォーマットで最終的な結果を報告してください：
   ```markdown
   # 実行結果報告

   ## 概要
   [全体の要約を簡潔に記述]

   ## 実行ステップ
   1. [ステップ1の説明と結果]
   2. [ステップ2の説明と結果]
   ...

   ## 最終成果物
   [成果物の詳細や、該当する場合はリンクなど]

   ## 課題対応（該当する場合）
   - 発生した問題と対応内容
   - 今後の注意点

   ## 注意点・改善提案
   - [気づいた点や改善提案があれば記述]
   ```

---

## 重要な注意事項

- 不明点がある場合は、作業開始前に必ず確認を取ってください。
- 重要な判断が必要な場合は、その都度報告し、承認を得てください。
- 予期せぬ問題が発生した場合は、即座に報告し、対応策を提案してください。
- **明示的に指示されていない変更は行わないでください。** 必要と思われる変更がある場合は、まず提案として報告し、承認を得てから実施してください。
- **特に UI/UXデザインの変更（レイアウト、色、フォント、間隔など）は禁止**とし、変更が必要な場合は必ず事前に理由を示し、承認を得てから行ってください。
- **技術スタックに記載のバージョン（APIやフレームワーク、ライブラリ等）を勝手に変更しないでください。** 変更が必要な場合は、その理由を明確にして承認を得るまでは変更を行わないでください。

---

# 技術スタック

@technologystack.md

---

# ディレクトリ構成

@directorystructure.md

以上の指示に従い、確実で質の高い実装を行います。指示された範囲内でのみ処理を行い、不要な追加実装は行いません。不明点や重要な判断が必要な場合は、必ず確認を取ります。

---

# project-overview.yaml
プロジェクト作業の前に必ずdocs/project-overview.yamlを確認し、プロジェクトの全体像を把握してください。このファイルにはプロジェクト構造、機能一覧、技術スタックなどの重要情報が含まれています。

作業開始前のチェックリスト：
1. docs/project-overview.yamlを読み、プロジェクト構造と既存機能を理解する
2. 実装予定の機能が既存機能と重複していないか確認する
3. 技術スタックとバージョンの制約を確認する

このプロジェクトでは、コード変更後に docs/project-overview.yaml を最新状態に更新してください。
変更点を説明し、YAMLファイルに必要な更新を提案してください。

問題解決が困難な場合のトラブルシューティング：
- 原因が不明確な問題に直面した場合は、project-overview.yamlの記述と実際のコードベースの一致を確認してください
- 不一致を発見した場合は、その差異を記録し、問題解決後にドキュメントを更新してください

---

# CSSコーディングガイドライン

## ベンダープレフィックス

CSSでベンダープレフィックスを使用する場合は、必ず標準プロパティも併記してください。
以下の原則に従ってください：

1. ベンダープレフィックスを使用する場合、必ず標準プロパティも定義する
2. ベンダープレフィックスを先に記述し、その後に標準プロパティを記述する
3. 値が同じ場合でも両方のプロパティを記述する

### 良い例

```css
.element {
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
}
```

### 悪い例

```css
.element {
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
}
```

この対応により、異なるブラウザエンジンでの互換性を確保し、「Also define the standard property 'X' for compatibility」といったエラーを防ぐことができます。

よく使われるベンダープレフィックスと対応する標準プロパティ：

- `-webkit-mask` → `mask`
- `-webkit-transform` → `transform`
- `-webkit-transition` → `transition`
- `-webkit-animation` → `animation`
- `-webkit-filter` → `filter`
- `-webkit-appearance` → `appearance`
- `-webkit-backdrop-filter` → `backdrop-filter`
- `-moz-appearance` → `appearance`
- `-ms-grid` → `grid`

---

# コード再利用性と保守性向上のためのガイドライン

## ディレクトリ構造と責務の分離

- 関心の分離原則に基づき、コードは明確な責務を持つディレクトリに配置する
- 以下のディレクトリ構造を遵守する：
  - `src/pages`: ルーティングとページコンポーネント
  - `src/components`: 再利用可能なUIコンポーネント
  - `src/context`: コンテキストプロバイダー
  - `src/providers`: 状態管理プロバイダー
  - `src/hooks`: カスタムフック
  - `src/lib`: ユーティリティ関数とFirebase連携
  - `src/styles`: グローバルスタイル
  - `src/schemas`: バリデーションスキーマ定義

## データ構造と権限モデルの変更に関する注意事項

- データ構造を変更する前に必ずFirebaseのセキュリティルール（firestore.rules）を確認する
- セキュリティルールとアプリケーションコードが一致することを確認する
- 既存の権限管理ロジックを十分に理解した上で設計変更を行う
- 以下のポイントを特に注意する：
  1. コレクションパス構造（例：`/supplements/{supplementId}`）の確認
  2. ドキュメント内のフィールド（例：`userId`）による権限制御の仕組みの把握
  3. 変更による既存データへの影響を事前に評価
  4. 必要に応じてデータ移行計画を立てる
- 既存のコードが適切に動作している場合は、不要な変更を避ける
- 変更を行う場合は必ず承認を得てから実施する

## Firebase連携コードに関するガイドライン

### セキュリティルールとの一貫性

- Firestoreのセキュリティルールと一致したデータアクセスロジックを実装する
- セキュリティルールを変更する場合は、対応するアプリケーションコードも更新する
- 以下の例のように、明示的にセキュリティルールとの関連をコメントで説明する：

```typescript
// セキュリティルールでは /supplements/{supplementId} パスで
// ドキュメントのuserIdフィールドと認証ユーザーIDを比較している
const getSupplementsCollection = () => {
  const user = firebase.auth().currentUser;
  if (!user) {
    throw new Error("ユーザーがログインしていません");
  }
  return firestore.collection("supplements");
};
```

### クライアント側の権限検証

- Firebaseのセキュリティルールだけでなく、クライアント側でも権限チェックを実装する
- データ操作前に自分のデータであることを確認する：

```typescript
// セキュリティチェック - 自分のドキュメントか確認
const doc = await supplementRef.get();
if (!doc.exists || doc.data()?.userId !== user.uid) {
  throw new Error("指定されたデータが存在しないか、アクセス権限がありません");
}
```

## バリデーションスキーマと型定義の管理

- Zodバリデーションスキーマは `src/schemas` ディレクトリに定義
- 機能ごとに別ファイルで管理（例：`auth.ts`, `supplement.ts`, `form-schemas.ts`）
- フォーム関連のバリデーションスキーマは `src/schemas/form-schemas.ts` に配置
- アプリケーション全体で使用する共通スキーマは `src/schemas/common.ts` に配置
- 型定義は各スキーマファイル内でスキーマから推論して定義（`z.infer<typeof schema>`）
- モデルとAPIの型変換はユーティリティ関数として `src/lib/type-guards.ts` に実装
- バリデーションスキーマはUIコンポーネントから分離し、スキーマファイルに集中管理する

### スキーマファイルの命名規則

- 基本的なドメインモデルのスキーマ: `src/schemas/{モデル名}.ts`（例: `user.ts`, `product.ts`）
- フォーム専用のスキーマ: `src/schemas/form-schemas.ts`（すべてのフォームのスキーマをまとめる場合）
- 複数のフォームスキーマを分割する場合: `src/schemas/{機能名}-forms.ts`（例: `auth-forms.ts`）

### スキーマの整理方法

- 同種のフォームスキーマは同じファイルにまとめる（例：認証関連のスキーマは `auth.ts` に）
- 再利用可能な共通バリデーションロジックは関数として抽出する（例：`numberFieldSchema()`）
- スキーマ間で共有する型や定数は適切に分離し、相互参照を最小限に保つ
- 型定義はスキーマと同じファイルに配置し、export して再利用できるようにする

## コードの再利用とユーティリティ関数の抽出

- 共通処理はユーティリティ関数として抽出
- ビジネスロジックとUIの分離を意識する
- 特定のドメインに関するロジックは対応するモジュールに集約
- バリデーションロジックはUIから分離してスキーマファイルに定義

## 拡張性を考慮した設計

- スキーマの変更がアプリケーション全体に影響しないように型を適切に定義
- バリデーションルールは集中管理し、変更が必要な場合は単一の場所で修正可能に
- 型定義は具体的かつ必要十分な情報を含むように設計

## エラー処理と型の安全性

- API通信など外部データを扱う際は型の安全性を確保するための変換関数を実装
- エラーハンドリングは明示的に行い、ユーザーフレンドリーなメッセージを表示
- フォームバリデーションのエラーメッセージは日本語で明確に表示
